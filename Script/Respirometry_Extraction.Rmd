---
title: SDR plate photosynthesis & respiration with LoLinR
author: "P Harnay"
date: '2025'
output:
  html_document:
    code_folding: hide
    toc: yes
    toc_depth: 6
    toc_float: yes
  pdf_document:
    keep_tex: yes
---
## Setup  

Set up workspace, set options, and load required packages.    
```{r}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

```{r, warning=FALSE, message=FALSE}
## install packages if you dont already have them in your library
if ("devtools" %in% rownames(installed.packages()) == 'FALSE') install.packages('devtools') 
library(devtools)
if ("segmented" %in% rownames(installed.packages()) == 'FALSE') install.packages('segmented') 
if ("plotrix" %in% rownames(installed.packages()) == 'FALSE') install.packages('plotrix') 
if ("gridExtra" %in% rownames(installed.packages()) == 'FALSE') install.packages('gridExtra') 
if ("LoLinR" %in% rownames(installed.packages()) == 'FALSE') install_github('colin-olito/LoLinR') 
if ("lubridate" %in% rownames(installed.packages()) == 'FALSE') install.packages('lubridate') 
if ("chron" %in% rownames(installed.packages()) == 'FALSE') install.packages('chron') 
if ("plyr" %in% rownames(installed.packages()) == 'FALSE') install.packages('plyr') 
if ("dplyr" %in% rownames(installed.packages()) == 'FALSE') install.packages('dplyr') 
if ("stringr" %in% rownames(installed.packages()) == 'FALSE') install.packages('stringr') 
if ("Rmisc" %in% rownames(installed.packages()) == 'FALSE') install.packages('Rmisc') 


#load packages
library("ggplot2")
library("segmented")
library("plotrix")
library("gridExtra")
library("LoLinR")
library("lubridate")
library("chron")
library('plyr')
library('dplyr')
library('stringr')
library('Rmisc')
library("ggpmisc")

```


## Respirometry in LoLinR

Modified from K. Wong, S. Gurr, A. Huffmyer, original H. Putnam scripts  

Set the path of all respirometry files within the R project.   

```{r, warning=FALSE, message=FALSE}
path.p<-"Ranalysis/data/Resp/Plates" #location of files
```

Bring in the file names.
```{r, warning=FALSE, message=FALSE}
# bring in the respiration file names
file.names<-basename(list.files(path = path.p, pattern = "csv$", recursive = TRUE)) #list all csv file names in the folder and subfolders
```

Generate respiration data frames.
```{r, warning=FALSE, message=FALSE}
#generate a 6 column dataframe with specific column names
Resp.R <- data.frame(matrix(NA, ncol=6))
colnames(Resp.R) <- c("Date", "Run", "Sample.ID","Chamber.ID","Intercept", "umol.L.min")

Resp.Rb <- data.frame(matrix(NA, ncol=6))
colnames(Resp.Rb) <- c("Date", "Run", "Sample.ID","Chamber.ID","Intercept", "umol.L.min")

```

Load in the sample information file. It is CRITICAL to have chambers in the order "A1, B1, C1, D1", rather than "A1, A2, A3, A4".  
```{r, warning=FALSE, message=FALSE}
Sample.Info<-read.csv("Ranalysis/data/Spat_Info.csv") #information on life stage, number of individuals, runs, etc.
rename <- Sample.Info$Chamber.ID
samp <- Sample.Info$Sample.ID
run <- str_sub(file.names, 10, 15) #extract run from file name
date <- str_sub(file.names, 1, str_length(file.names)-16) #extract date from file name

#load in respiration start times as a list the same length as the number of files
starttimes<-read.csv("Ranalysis/data/Resp/starttimes.csv") #read in file of starting times of the oxygen measurements
rtime<-starttimes$Rtime #list respiration start times. 
```

Run loop to extract slopes from respiration data. Subset for respiration data by filtering time >= respiration start time. 

```{r, results=FALSE, warning=FALSE, message=FALSE}
for(i in 1:length(file.names)) { # for every file in list start at the first and run this following function
  Resp.Data <-read.table(file.path(path.p,file.names[i]), skip = 56, header=T, sep=",", na.string="NA", fill = TRUE, as.is=TRUE, fileEncoding="latin1") #reads in the data files
  Resp.Data$Temp <- Resp.Data[,31] #assigns temp column
  Resp.Data$Time.Min <- seq.int(from=0, to=((nrow(Resp.Data)*0.25)-0.25), by = 0.25) #set time in minutes
  Resp.Data <- Resp.Data %>% #filters data by phase (respiration only)
     filter(Time.Min > rtime[i])
  Resp.Data.N <- Resp.Data[,3:26] #subset desired columns
  
  for(j in 1:(ncol(Resp.Data.N))){
    model <- rankLocReg(
      xall=Resp.Data$Time.Min, yall=as.numeric(Resp.Data.N[, j]), 
      alpha=0.4, method="pc", verbose=TRUE) #extract slopes, percentile rank method with minimum window size of 0.4. This means that in order to fit a slope, it has to encompass at least 40% of available datapoints. 
    
    pdf(paste0("Ranalysis/data/Resp/RespirationPlots/",date[i], "_",run[i],"_",rename[j],"_regression_trunc.pdf")) #generate output file names
    plot(model)
    dev.off()
    
    Resp.Rb[j,1] <- as.character(date[i]) #stores the date
    Resp.Rb[j,2] <- as.character(run[i]) #stores the run number
    Resp.Rb[j,3] <- as.character(samp[j+(i-1)*ncol(Resp.Data.N)]) #stores the sample ID
    Resp.Rb[j,4] <- as.character(rename[j]) #stores the chamber ID
    Resp.Rb[j,5:6] <- model$allRegs[i,c(4,5)] #inserts slope and intercept in the dataframe
    
  }
  Resp.R <- rbind(Resp.R, Resp.Rb) #bind final data frame
}

```

Save respiration data frames.  
```{r, results=FALSE, warning=FALSE, message=FALSE}
Resp.R <- Resp.R[-1,] #remove empty row

write.csv(Resp.R, paste0("Ranalysis/data/Resp/Respiration_rates_Spis_May2023.csv", sep="")) #save respiration rate data
```


Start here for analysis after the rates have already been extracted, so you don't have to run all of the regressions every time.
```{r, warning=FALSE, message=FALSE}
Resp.Rates <- read.csv(file = "Ranalysis/data/Resp/Respiration_rates_Spis_May2023.csv") #read file back in so slopes don't have to be generated every time
Resp.Rates <- subset(Resp.Rates, select = -c(X) ) #remove empty column

#format "Date" column
Resp.Rates$Date <- gsub("_.*", "", Resp.Rates$Date)  
Resp.Rates$Date <- as.numeric(as.character(Resp.Rates$Date))

Sample.Info<-read.csv("Ranalysis/data/Spat_Info.csv") #information on life stage, number of individuals, runs, etc.
```

Merge Resp values with sample info for data visualization, outlier removal, and statistical testing  
```{r, warning=FALSE, message=FALSE}
oxygen<-left_join(Sample.Info, Resp.Rates, by="Sample.ID") #add respiration data
colnames(oxygen)[colnames(oxygen) == 'Intercept'] <- 'Resp.Intercept' #rename to specify Respiration
colnames(oxygen)[colnames(oxygen) == 'umol.L.min'] <- 'R.umol.L.min' #rename to specify Respiration

ggplot(oxygen, aes(R.umol.L.min, Plate.ID,)) + #plot to visualize data
  geom_point()
```


Account for volume and substract blank values. Average blank calculated for each run. Display mean blank value in order of R .    
```{r, results=TRUE, warning=FALSE, message=FALSE}
#Account for chamber volume to convert from umol L-1 m-1 to umol m-1. This standardizes across water volumes (different because of coral size) and removes per Liter
oxygen$R.umol.min <- oxygen$R.umol.L.min * oxygen$Volume #calculate units per time

ggplot(oxygen, aes(R.umol.min, Plate.ID,)) + #plot to visualize data
  geom_point()

blank_data <- subset(oxygen, Type == "Blank") #subset to blank data only
ggplot(blank_data, aes(R.umol.min, Plate.ID)) + #plot to visualize data, should be 0 or <0
  geom_point() 

```

Remove blank wells that are outliers.  
```{r}
#filter dark phase blank values
#blank_data<-blank_data %>%
#  filter(R.umol.min > -0.0002) %>%
#  filter(R.umol.min < 0)

ggplot(blank_data, aes(R.umol.min, Plate.ID,)) +
  geom_point()

#calculate mean blank values
meanRblank<-mean(blank_data$R.umol.min) #mean R phase blanks

```


```{r}
oxygen$code<-paste(oxygen$Date, oxygen$Plate.ID)
plot(oxygen$R.umol.min~as.factor(oxygen$code), ylab="umol O2 min-1")
```

```{r}
 #blank per plate
resp.blnk <- aggregate(R.umol.min ~ Plate.ID, data=blank_data, mean) #calculate average blank per plate
colnames(resp.blnk)[colnames(resp.blnk) == 'R.umol.min'] <- 'R.Blank.umol.min' #rename to specify blank for R

```



Merge together.  
```{r}
oxygen <- full_join(oxygen, resp.blnk) #add R blanks to master
```
Add blank values into data frame and add average blank value to replace NA values from any runs that do not have blank values    
```{r}
oxygen<-oxygen%>%
  mutate(R.Blank.umol.min = ifelse(is.na(R.Blank.umol.min), meanRblank, R.Blank.umol.min))

oxygen$R.Blank.umol.min <- meanRblank

```

Subtract blank values to generate a "corrected" value for umol O2 sec-1.  

```{r, warning=FALSE, message=FALSE}
range(oxygen$R.umol.min*10000)

range(oxygen$R.Blank.umol.min*10000)

oxygen$R.umol.min.corr<-oxygen$R.umol.min-oxygen$R.Blank.umol.min #subtract R blanks

range(oxygen$R.umol.min.corr*10000)

ggplot(oxygen, aes(R.umol.min.corr, Plate.ID)) + 
  geom_point()

```

Normalize to biologically relevant measure. Here, normalize to size of spat. This can be substituted or changed for larval size/volume as well.  

```{r, warning=FALSE, message=FALSE}
oxygen.bio <- oxygen %>% filter(Type == "Coral") #isolate only biological samples and drop unused factor levels 
oxygen.bio <- droplevels(oxygen.bio) #drop unused factor levels
oxygen.bio$Size.mm2 <- as.numeric(as.character(oxygen.bio$Size.mm2))

#respiration
oxygen.bio$R.umol.mm2.min <- oxygen.bio$R.umol.min.corr/oxygen.bio$Size.mm2 #calculate oxygen per organism (larvae or recruit)

oxygen.bio$R.nmol.mm2.min <- oxygen.bio$R.umol.mm2.min*1000 #calculate nanmoles 

ggplot(oxygen.bio, aes(R.nmol.mm2.min, Plate.ID)) + 
  geom_point()


#filter outliers
oxygen.bio <- oxygen.bio %>% 
  filter(R.nmol.mm2.min > -0.15) %>%
  filter(R.nmol.mm2.min < 0)

ggplot(oxygen.bio, aes(R.nmol.mm2.min, Plate.ID)) + 
  geom_point()


```

```{r}
ggplot(oxygen.bio, aes(R.nmol.mm2.min, Plate.ID,)) + 
  geom_point()

#Plot Resp as a function of Polyp Number
ggplot(data = oxygen.bio, aes(x = as.numeric(Polyp.Number), y = R.nmol.mm2.min)) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("eq", "R2","P")), size = 4) +
  geom_point() +
  theme_classic()

#Plot Resp as a function of Size
ggplot(data = oxygen.bio, aes(x = Size.mm2, y = R.nmol.mm2.min)) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("eq", "R2","P")), size = 4) +
  geom_point() +
  theme_classic()

#Plot Resp as a function of Size
ggplot(data = oxygen.bio, aes(x = log10(Size.mm2+1), y = log10(R.nmol.mm2.min+1))) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("eq", "R2","P")), size = 4) +
  geom_point() +
  theme_classic()


```


Save as .csv file.  
```{r, warning=FALSE, message=FALSE}
write.csv(oxygen.bio, paste0("Ranalysis/output/Spis_spat_RespRates.csv", sep="")) #save final file
```


